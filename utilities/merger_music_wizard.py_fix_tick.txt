    def _on_play_tick(self):
        if self._is_syncing: return
        self._is_syncing = True
        try:
            now = time.time()
            # Only perform heavy project sync checks every 100ms
            do_heavy = (now - self._last_tick_ts > 0.1)
            if do_heavy:
                self._last_tick_ts = now

            # 1. Step 2 Preview (Audio Only)
            if self.stack.currentIndex() == 1 and self._player:
                try:
                    st = self._player.get_state()
                    if st == 3: # Playing
                        vlc_ms = int(self._player.get_time() or 0)
                        if vlc_ms <= 0: vlc_ms = self._last_good_vlc_ms
                        else: self._last_good_vlc_ms = vlc_ms
                        
                        vlc_ms = int(vlc_ms + PREVIEW_VISUAL_LEAD_MS)
                        max_ms = self.offset_slider.maximum()
                        vlc_ms = max(0, min(max_ms, vlc_ms))
                        
                        if vlc_ms >= max_ms - 10:
                            self._on_vlc_ended()
                            return

                        if not self._dragging and not self._wave_dragging:
                            self.offset_slider.blockSignals(True)
                            self.offset_slider.setValue(vlc_ms)
                            self.offset_slider.blockSignals(False)
                            self._sync_caret()
                    elif st == 6: # Ended
                        self._on_vlc_ended()
                except Exception as e:
                    self.logger.debug(f"WIZARD: Play tick error (audio): {e}")

            # 2. Step 3 Timeline Preview (Video + Audio)
            if self.stack.currentIndex() == 2 and self._video_player:
                try:
                    # Ignore tick updates if we just sought (prevents stutter/jump-back)
                    if now - self._last_seek_ts < 0.5:
                        self._last_clock_ts = now
                        return

                    st = self._video_player.get_state()
                    # 1=Opening, 2=Buffering, 3=Playing
                    if st in (1, 2, 3):
                        v_time = self._video_player.get_time() / 1000.0
                        if v_time < 0: v_time = 0.0
                        
                        # Use system clock to fill gaps during file swaps
                        clock_delta = now - self._last_clock_ts
                        self._last_clock_ts = now
                        
                        if do_heavy:
                            # Calculate absolute project time and update offset cache
                            curr_media = self._video_player.get_media()
                            if curr_media:
                                curr_mrl = str(curr_media.get_mrl()).lower().replace("%20", " ").replace("file:///", "").replace("/", "")
                                
                                temp_elapsed = 0.0
                                matched_idx = -1
                                for i, seg in enumerate(self.video_segments):
                                    seg_path_norm = seg["path"].lower().replace("/", "")
                                    # Flexible path matching
                                    if seg_path_norm in curr_mrl or curr_mrl in seg_path_norm or os.path.basename(seg_path_norm).lower() in curr_mrl:
                                        matched_idx = i
                                        break
                                    temp_elapsed += seg["duration"]
                                
                                if matched_idx != -1:
                                    self._current_elapsed_offset = temp_elapsed
                                    
                                    # Handle Auto-Swap to Next Video
                                    if st == 3 and v_time >= self.video_segments[matched_idx]["duration"] - 0.2:
                                        if matched_idx < len(self.video_segments) - 1:
                                            next_path = self.video_segments[matched_idx + 1]["path"]
                                            m = self.vlc.media_new(next_path)
                                            self._video_player.set_media(m)
                                            self._video_player.play()
                                        else:
                                            # Finished last segment
                                            self.toggle_video_preview() 
                                            self.timeline.set_current_time(self.total_video_sec)
                                            return

                                    if self._player:
                                         self._sync_music_only_to_time(self._current_elapsed_offset + v_time)
                        
                        # Smooth update: Use player time if playing, otherwise extrapolate
                        if st == 3:
                            project_time = self._current_elapsed_offset + v_time
                        else:
                            project_time = self.timeline.current_time + clock_delta
                            
                        project_time = min(self.total_video_sec, max(0.0, project_time))
                        self.timeline.set_current_time(project_time)
                        self._sync_caret()
                    else:
                        self._last_clock_ts = now
                except Exception as e:
                    self.logger.debug(f"WIZARD: Play tick error (video): {e}")
            else:
                self._last_clock_ts = now
        finally:
            self._is_syncing = False
