$excludedDirNames=@('binaries','config','logs','mp3','!!!_Ouput_Video_Files_!!!')
$excludedFileNames=@('app.py','Installer.ps1','project_structure.txt')
$allowedExtensions=@('.py','.txt','.md','.json','.ini','.cfg','.yml','.yaml','.js','.ts','.html','.css','.qss','.bat','.cmd','.ps1')
function Get-TargetFiles{Get-ChildItem -Recurse -File|Where-Object{if($excludedFileNames-contains $_.Name){return $false}if($allowedExtensions-notcontains $_.Extension.ToLowerInvariant()){return $false}$dirParts=$_.DirectoryName -split '[\\/]';foreach($d in $excludedDirNames){if($dirParts-contains $d){return $false}}return $true}}
function Get-FlaggedItemsForFile{param([Parameter(Mandatory=$true)][string]$FilePath)$lines=Get-Content -LiteralPath $FilePath;$items=New-Object System.Collections.Generic.List[object];for($i=0;$i -lt $lines.Count-1;$i++){$cur=$lines[$i];$next=$lines[$i+1];$isEmpty=($cur -match '^\s*$');$isFullLineComment=(($cur -match '^\s*\#')-or($cur -match '^\s*\*\*')-or($cur -match '^\s*//')-or($cur -match '^\s*;')-or($cur -match '^\s*/\*')-or($cur -match '^\s*\*/')-or($cur -match '^\s*\*'));$hasBlockInlineComment=($cur -match '/\*.*\*/');$hasHashInlineComment=($cur -match '\s#(?![0-9A-Fa-f]{3,8}\b)');$isComment=($isFullLineComment -or $hasBlockInlineComment -or $hasHashInlineComment);if(($isEmpty -or $isComment) -and ($next -notmatch '^\s*(def|class|from|import)\b')){$kind=if($isEmpty){'EMPTY'}else{'COMMENT'};$items.Add([pscustomobject]@{FilePath=$FilePath;LineIndexZeroBased=$i;LineNumberOneBased=($i+1);Kind=$kind;IsEmpty=$isEmpty;IsFullLineComment=$isFullLineComment;HasBlockInlineComment=$hasBlockInlineComment;HasHashInlineComment=$hasHashInlineComment;OriginalLine=$cur})}}return $items}
function Apply-SurgicalRemovalsForFile{param([Parameter(Mandatory=$true)][string]$FilePath,[Parameter(Mandatory=$true)][System.Collections.Generic.List[object]]$FlaggedItems)if(-not(Test-Path -LiteralPath $FilePath)){return}$lines=Get-Content -LiteralPath $FilePath;$removeLineIndexes=New-Object 'System.Collections.Generic.HashSet[int]';foreach($it in $FlaggedItems){if($it.IsEmpty -or $it.IsFullLineComment){[void]$removeLineIndexes.Add([int]$it.LineIndexZeroBased)}}$newLines=New-Object System.Collections.Generic.List[string];for($i=0;$i -lt $lines.Count;$i++){if($removeLineIndexes.Contains($i)){continue}$line=$lines[$i];$inlineItems=$FlaggedItems|Where-Object{$_.LineIndexZeroBased -eq $i -and -not $_.IsEmpty -and -not $_.IsFullLineComment};if($inlineItems.Count -gt 0){$hasBlock=$false;$hasHash=$false;foreach($it in $inlineItems){if($it.HasBlockInlineComment){$hasBlock=$true}if($it.HasHashInlineComment){$hasHash=$true}}if($hasBlock -and ($line -match '/\*.*\*/')){$line=[regex]::Replace($line,'/\*.*?\*/','')}if($hasHash -and ($line -match '\s#(?![0-9A-Fa-f]{3,8}\b)')){$line=[regex]::Replace($line,'\s#(?![0-9A-Fa-f]{3,8}\b).*$', '')}$line=$line.TrimEnd()}$newLines.Add($line)}$oldText=($lines -join "`n");$newText=($newLines.ToArray() -join "`n");if($newText -ne $oldText){Set-Content -LiteralPath $FilePath -Value $newText}}
Write-Output 'Instructions for an AI Agent: Below are result of comments and empty lines which should be removed from the code which is inside the files. when removing these below comments, or empty lines, please becareful not to touch or hurt the code. only remove the comment and empty line surgecly, without impacting the code:'
$allFlagged=New-Object System.Collections.Generic.List[object]
Get-TargetFiles|ForEach-Object{$file=$_.FullName;$items=Get-FlaggedItemsForFile -FilePath $file;foreach($it in $items){$cur=$it.OriginalLine;"{0}:{1} [{2}] {3}" -f $it.FilePath,$it.LineNumberOneBased,$it.Kind,($cur -replace "`t","    ");$allFlagged.Add($it)}}
Write-Output "";Write-Output "";Write-Output "------------------------------------------------------------------------";Write-Output "------------------------------------------------------------------------";Write-Output "";Write-Output ""
$answer=Read-Host 'Do you wish me to go a head and perform these replacements now for you? (Y/N)';$answer=($answer+'').Trim()
if($answer -match '^(Y|YES)$'){$byFile=$allFlagged|Group-Object -Property FilePath;foreach($group in $byFile){$filePath=$group.Name;$itemsList=New-Object System.Collections.Generic.List[object];foreach($x in $group.Group){$itemsList.Add($x)}Apply-SurgicalRemovalsForFile -FilePath $filePath -FlaggedItems $itemsList}Write-Output "Done. Replacements applied to the flagged lines only."}else{Write-Output "No changes were made."}
