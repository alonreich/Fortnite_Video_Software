# Project Vision: Fortnite Video Crop Coordinate Configurator

## 1. Core Purpose
This desktop application, built specifically for Windows, works alongside a separate video-processing tool. Its primary function is to help creators define the precise coordinates and final placement of Heads‑Up Display (HUD) elements from a Fortnite gameplay video. These coordinates and placements are stored in a fixed JSON configuration file located in `..\processing\`, which the processing tool reads to produce perfectly cropped 9:16 portrait‑mode videos for mobile platforms. The aspect ratio is fixed at 9:16 and cannot be changed.

## 2. Core Workflow
1. **Load Sample Video:** The user loads a single video file (`.mp4`, `.avi`, `.mkv`). The tool is intended for one video at a time and supports only video file types.
2. **Navigate to a Reference Frame:** Video playback controls—play, pause, a seek bar, and keyboard shortcuts such as left/right arrow keys for frame‑accurate seeking—help the user find a frame where all HUD elements are clearly visible.
3. **Take a Snapshot:** Clicking "START CROPPING" freezes the current frame and opens the cropping interface.
4. **Define Crop Regions:** The user can mark a HUD element in two ways:
   * **Manual Drawing:** Click and drag to draw a rectangle around the HUD component.
   * **Magic Wand/Template Matching:** After taking a snapshot, the "MAGIC WAND" button becomes available. Clicking it triggers template matching using anchor images to detect common Fortnite HUD elements (Loot Area, Mini Map + Stats, Health Bar, Teammates Health). Suggested regions are overlaid on the snapshot; the user can cycle through detected regions.
5. **Tag Element:** Once a rectangle is defined, the user tags it with one of several Fortnite-specific preset roles: "Loot Area", "Mini Map + Stats", "Own Health Bar (HP)", "Boss HP (For When You Are The Boss Character)", or "Teammates health Bars (HP)". Note: Health Bar includes both health and shield components as they are combined in Fortnite.
6. **Fine‑Tune in Portrait Composer:** Immediately after tagging, focus shifts to a separate "Portrait Composer" window (titled "Portrait 1280x1920"), showing the selected element on a 9:16 canvas. The element is auto‑placed based on its role (e.g., loot goes bottom-right, health goes bottom-left). The user can drag it to reposition and use handles to resize it, defining its final scale and location within the portrait layout. **NOTHING IS SAVED UNTIL** the user clicks **"FINISH & SAVE"**.
7. **Repeat for All Elements:** Steps 4–6 are repeated for each HUD component that the user wants to appear in the portrait video. When saving, the application surgically updates only the HUD elements that were present in the portrait composer, leaving other configured elements untouched.

## 3. Key Features & Logic
* **Undo/Redo:** Cropping actions can be undone or redone via `Ctrl+Z` and `Ctrl+Y` (with functional undo/redo buttons).
* **Configuration Management:** The application writes coordinate and placement data to a JSON file in `..\processing\` **only when the user clicks "FINISH & SAVE"**. It performs surgical updates—modifying only elements present in the portrait composer while preserving others.
* **Coordinate Validation:** Crops are validated to ensure they lie within the video frame; invalid coordinates trigger an error.
* **Guided UI:** A blinking text overlay appears at each step to guide the user on what to do next. No sidebar is used.
* **Preset HUD Roles:** Fortnite-specific HUD roles are preconfigured: Loot Area, Mini Map + Stats, Own Health Bar (HP), Boss HP, Teammates health Bars (HP).
* **No Caching:** The implementation avoids generating cache files (e.g., `__pycache__`) using environment variables.
* **Fortnite‑Specific:** The tool is tailored for Fortnite with game-specific HUD detection and does not support other games.
* **Accessibility:** The interface supports keyboard navigation (arrow keys for frame seeking and element movement in portrait composer).
* **Zoom Limits:** Both landscape and portrait windows prevent zooming out beyond the point where black voids/empty space would appear around the image.
* **UI Consistency:** All buttons have consistent heights, colors, and sizing. Window titles are standardized: "Crop Tool Wizard" for main window, "Portrait 1280x1920" for portrait composer.

# ==============================================================================
# COORDINATE SYSTEM & SCALING LOGIC (CRITICAL FOR AI AGENTS)
# ==============================================================================
# The Crop Tool and Processing Engine usage a unique "Scale-Out" architecture to ensure high quality.
#
# 1. THE UI SPACE (1080x1920, WITH 1080x1620 CONTENT AREA):
#    - The Crop Tool's Portrait View uses a 1080x1920 canvas.
#    - The Top 150 pixels (y=0 to y=150) are STRICTLY RESERVED for the text/header canvas.
#    - HUD elements are constrained to the 1080x1620 CONTENT AREA (y=150..1920).
#    - IMPORTANT: crops_coordinations.conf stores crop rectangles in the CONTENT AREA
#      coordinate space (1080x1620), i.e., y is relative to the content area and does
#      NOT include the top 150px padding. Overlay positions are stored in full 1080x1920.
#
# 2. THE PROCESSING SPACE (1280x1920):
#    - The backend (filter_builder.py) scales the main video to 1280x1920 (TARGET_W=1280) first.
#    - This scaling (1280p) is larger than the UI space (1080p).
#    - Why? To allow the 1080p content to be "centered" or manipulated with high fidelity before final output.
#
# 3. THE TRANSFORMATION PIPELINE:
#    - CONFIG -> BACKEND (1280x1920 canvas):
#         a. Crop Rect (content area): X_canvas = X_content * BACKEND_SCALE
#         b. Crop Rect (content area): Y_canvas = Y_content * BACKEND_SCALE
#         c. Element Size: Size_canvas = (Size_content * user_scale) * BACKEND_SCALE
#    - BACKEND -> FFmpeg:
#         a. The *Source Crop* is computed by inverting the content-area transform back
#            to the original resolution using the same scale+center-crop math as FFmpeg.
#         b. The *Overlay Position* is computed by scaling overlay x,y from 1080x1920
#            to 1280x1920, and then subtracting the 150px top padding after scaling.
#         c. The *Element Size* is also scaled to 1280x1920 to preserve relative size.
#
# 4. KEY TAKEAWAY:
#    - Crop rectangles are stored in 1080x1620 content space; overlay positions are in 1080x1920.
#    - The 150px top padding is applied ONLY to overlay positioning, not crop rectangles.
#    - Do NOT remove the top-bar restriction; it protects the text layer.
#    - Do NOT change the scaling logic without understanding the full round-trip:
#      Original -> 1280x1920 (scale+crop) -> 1080x1620 content -> config -> back to original.